# 摘要
我们对DNSSEC签名域的加密图形安全性进行了首次互联网研究。为此，我们为流行域名收集了210万DNSSEC密钥，其中190万是RSA密钥。我们分析了RSA密钥，发现有很大一部分签名域使用了易受攻击的密钥：35%的签名域使用的是与其他域共享其模数的RSA密钥，66%的签名域所使用的密钥太短（1024bit或更小），或是模数GCD大于1的密钥与其他域的模数。如我们所示，这些漏洞在很大程度上是由于糟糕的密钥生成实践，但也可能是由于潜在的硬件或软件错误。我们对DNSSEC公司签名域的密码图形安全性进行了第一次互联网研究.为此，我们收集了210万DNSSEC公司密钥，其中1.9米是RSA算法密钥。我们对RSA算法密钥进行了分析，发现有符号域中有很大一部分使用了易受攻击的密钥：35%的域使用与其他域共享模的RSA算法密钥，66%的域使用太短(1024位或以下)的密钥，或者模数大于1.的密钥与其他域的密钥相同。正如我们所显示的那样，在很大程度上，这些漏洞是由于关键成因实践不佳，但也是由于潜在的硬件或软件错误。每天使用我们开发的DNSSEC密钥验证引擎进行DNSSEC密钥收集和分析。这些统计数据以及DNSSEC密钥验证引擎可在线提供，作为互联网用户的一项服务。
DNSSEC公司键的收集和分析是与我们开发的DNSSEC公司键Valida公司引擎在日常基础上形成的。该统计数据以及DNSSEC公司密钥验证引擎可在线提供，作为互联网用户的一项服务。
# 相关工作
我们的工作是有关测量DNSSEC在互联网上的使用和评估漏洞的研究，最突出的是SSL/TLS。我们首先将易损密码学的评估与以往工作中的研究进行了比较，然后回顾了早期采用DNSSEC的方法。   
密码的安全性取决于密钥生成过程中使用的运行状态。利用随机数生成器中的随机性不足的攻击由来已久，例如[5,7,9,12,20,21,16]。也有针对依赖于随机性来源的系统的攻击，例如，[30]中使用了伪随机数生成器中的不充分随机性来预测Bind实现选择的TXID值。2008年，[46]观察到，由于实现错误，Debian OpenSSL的伪随机数生成器是可预测的。   
由于不同的实现错误，最广泛采用的加密机制SSL/TLS经历了许多攻击，例如[13,2]。有关SSL/TLS中漏洞的全面综述，请参见[35]。   
与我们的工作最相关的是Heninger等人[22]，他们对TLS证书和SSH密钥进行了互联网范围的扫描，以分析随机数生成器（RNG）的安全性，并在大约1%的TLS证书和SSH主机中发现了漏洞。他们表明，绝大多数易受攻击的主机都是无头和嵌入式设备，缺乏足够的随机性。与此相反，在我们的工作中，我们研究了注册器和DNSShosting提供程序，它们具有生成必要随机性所需的基础结构，但我们发现DNSSEC签名区域中易受攻击密钥的比例明显大于TLS和SSH中[22]密钥所测得的比例。我们的工作结果扩展了[22]的结论，特别是，我们表明随机性问题不是受限嵌入设备固有的，而是更重要的-我们表明，即使是大型和流行的DNS托管提供商和注册商也会将漏洞引入多个签名域。我们的工作提供了证据，表明随机性问题不仅是由于资源有限的设备，而且更广泛，适用于具有必要手段来产生安全所需随机性的平台。   
[4] 执行1024位RSA密钥的因子分解。一些密钥由于共享时间而容易受到攻击，这些时间允许通过批量GCD计算进行有效的因子分解，而其他密钥则通过利用随机生成过程进行因子分解。   
以前在域中采用DNSSEC的工作测量了签名域的一部分[47，27]，或签名域中的错误配置[10，11]，这导致可用性降低。还研究了DNS在基础架构中的客户端，主要测量验证解析器的分数[33，19]。针对NSEC3的区域计数首先由Bernstein[3]和Wander等人[45]进行。最近Goldberg等人[18]表明，改进NSEC3的建议也容易受到区域枚举的影响，并提出了[17]。[43]中讨论了对DNS进行大规模主动测量的挑战，该研究设计并开发了用于收集和分析来自多个域的DNS数据包的基础设施。由于测量基础设施产生的大量流量（例如，com中的123M个域）以及每天重复数据收集的要求，[43]与我们的工作相比，具有不同的延迟和存储考虑因素。特别是，我们只关注900K个签名域。与[43]相反，我们处理结果并将其显示在报告中。
# DNS和DNSSEC的背景介绍
## 域名系统（DNS）
DNS是一个分布式数据库，包含从域名到不同值的资源映射（也称为资源记录（RR））。最流行和广泛使用的映射。[15] ，表示将域名映射到其IPv4地址的IP地址（由Atype RR表示），以及将名称服务器映射到域名的名称服务器（由Ns类型RR表示）。DNS中的资源记录对应于组织和网络运行的不同服务，例如主机、服务器、网络块。
这些区域是分层结构的，根区域位于第一级，顶级域（TLD）位于第二级，数百万个二级域（SLD）位于三级。13个根服务器的IP地址通过提示文件提供，或编译到DNS解析器软件中，当解析器的缓存为空时，每个解析过程都从根开始。根据DNS请求中的查询，根名称服务器通过引用响应类型将解析器重定向到相应的TLD，请求资源位于该TLD下。有许多TLD类型，最值得注意的是：国家代码TLD（ccTLD），其主要（通常）分配给国家，例如美国、il、de和通用TLD（gTLD）。组织（例如com、org）以及美国政府和军方（例如gov、mil）使用其域。SLD中的域也可以用于进一步委托子域或实体，或者可以由组织直接管理，例如ibm。com、google.com。
## DNSSEC   
普通的DNS请求和响应不受保护，因此会使DNS解析器暴露于DNS缓存中毒，从而恶意实体提供的更改的DNS记录会将客户端重定向到不正确的主机。Suchattacks可以由MitM或非路径攻击者发起。例如，恶意无线客户端可以利用其他客户端的通信，并可以通过恶意构建的DNS响应来响应其DNS请求，其中包含伪造的IP地址，例如，将客户端重定向到钓鱼网站。
域名系统安全扩展（DNSSEC）标准[RFC4033-RFC4035]通过对DNS资源记录进行加密数字签名来提供数据完整性和来源真实性，以防止缓存中毒。数字签名使支持NSSEC验证的接收解析器能够验证DNS响应中的数据是否与目标域区域文件中发布的数据相同。
**新资源记录（RR）**。DNSSEC定义了新的RR，以便存储用于验证响应的签名和密钥。例如，类型RRSIG记录包含签名认证和RR集，即特定域名的特定类型的所有映射。DNSKEY是区域的公钥，应用于验证区域授权的资源记录上的签名。使用相应的私有签名密钥计算签名，然后将其存储在RRSIG RR中。私有签名密钥应保密，建议脱机存储（以防止在名称服务器受损的情况下暴露）。
为了能够验证DNSKEY是否正确，重新求解器还从父区域获得DS RR，其中包含子区域公钥的哈希；如果DNSKEY中的值与父级的Delegation Signer DS记录中的（散列）值相同，则重新求解器将子级的DNSKEY接受为真实的。由于父级的DS记录已签名，因此保证了真实性。
**信任锚和信任链**。为了验证（可能）数百万域的日期密钥，解析器应该预先配置根的公共验证密钥。为了验证目标域的密钥，例如foo.bar，解析器需要通过跟踪和验证中间域的密钥来建立从根到目标域密钥的信任链。
一系列DNSKEY和DS RR形成了一个签名数据链，由从目标区域到根的路径上的每个节点之间的链接组成。DS RR在父级验证子级的DNSKEY。身份验证从DNS根区域的一组经过验证的公钥开始，DNS根区域是受信任的第三方。这允许解析器构造从根到目标区域的DNSKEY的链。父项的公钥用于验证DS RR上的签名（在RRSIG中），该签名包含子项的公钥。通过这种方式，可以从子区域构建到子区域的链接。解析器将继续这种方式，直到建立从目标区域到根的路径。如果孩子的DNSKEY在父区域没有有效的DS RR，则信任链断开，解决方案不安全。
**DNSSEC加密构建块**。DNSSEC使用一组固定的加密算法和哈希函数6，最常用的是：RSA/SHA-256、RSA/SHA-512[RFC5702]。如第5节所示，最广泛支持的算法是RSA（有不同的变体）。因此，在本节的补充部分，我们回顾了RSA，并解释了我们将在接下来的部分中使用的两种攻击，以识别易受攻击的密钥。
**RSA算法和攻击**
RSA算法：P=11 Q=5 N=55 F(n)=40 E=3 D=27 M=2 C=8 M=2   
**共享模攻击**
最开始拥有私钥(e,N)和公钥(d,N)，可以将N分解成P和Q，
因为有e·d=1mod((p-1)(q-1))
所以有常数c使得e·d-1=c(p-1)(q-1)
定义U=p+q=n+1-(ed-1)/c
存在函数y(x)=(x-p)(x-q)=x^2-Ux+N
所以q和p是函数y(x)的俩个根，y(x)是x关于e、d、N的，所以给了公钥和私钥就可以分解出q和p
拥有P和Q可以计算出![image](https://user-images.githubusercontent.com/49114842/203538871-1f31fbde-37ba-46dd-b383-80afc22ad2ed.png)
所以有一已知的密钥对(e1，N)(d1,N)，给定一公钥（e2,N）可以求出对应的(d2，N）
# **不过我有一个问题，就是说RSA里的N是由俩个质数相乘获得的，因此应该不存在俩对不同的密钥共用同一个N，如果有好兄弟知道这是为什么的，欢迎来给弟弟指点一下**
**分解模攻击**
三个质数P、Q、R，其中PQ组成一个rsa公私钥，其公钥是（d1,N1）、QR生成一个公私钥,其公钥是（d2,N2)，就算俩个公钥中N的最大公约数即GCD(N1,N2)=Q，所以就知道了Q和R，因此就可以通过公钥求出目标的私钥
这个攻击的重点在于尽可能多的收集大量的公钥，拿着这些公钥去算GCD值，它相对于传统的爆破，它依赖于有些发行商，会重复使用收集到的质数（Q和P）
